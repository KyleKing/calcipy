<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>dash_dev.tag_collector API documentation</title>
<meta name="description" content="Collect issue tags and output for review in a single location." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>
a {
text-decoration: underline;
}
h1,h2,h3,h4 {
font-weight: 400;
}
h2 {
margin: 0.50em 0 .25em 0;
}
dd p {
margin: 5px 0;
}
dl dl:last-child {
margin-bottom: 2.5em;
}
main {
margin-bottom: 80vh;
}
#content {
max-width: 1100px;
}
.source summary {
background-color: #fafafa; /* match HLJS background */
padding: 1px 5px;
}
.source summary:focus {
outline: none !important;
}
.source pre {
background-color: #fafafa; /* match HLJS background */
}
.source pre code {
padding-bottom: 1em;
}
table, th, td {
border: 1px solid #d4d4d4;
padding: 0 5px;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dash_dev.tag_collector</code></h1>
</header>
<section id="section-intro">
<p>Collect issue tags and output for review in a single location.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Collect issue tags and output for review in a single location.&#34;&#34;&#34;

# PLANNED: Revisit and standardize wording for tag vs. task vs. comment

import re
from collections import defaultdict
from pathlib import Path
from typing import List, Pattern, Sequence

import attr
from loguru import logger

from . import __pkg_name__
from .doit_helpers.base import debug_task, read_lines
from .doit_helpers.doit_globals import DIG, DoItTask
from .log_helpers import log_fun

_TAG_SUMMARY_FILENAME = &#39;TAG_SUMMARY.md&#39;
&#34;&#34;&#34;Name of the tag summary file.&#34;&#34;&#34;  # PLANNED: Maybe make this configurable?


@attr.s(auto_attribs=True)
class _TaggedComment:  # noqa: H601
    &#34;&#34;&#34;Tagged (FIXME,TODO,etc) with contextual information.&#34;&#34;&#34;  # noqa: T100,T101

    lineno: int
    tag: str
    text: str


@attr.s(auto_attribs=True)
class _Tags:  # noqa: H601
    &#34;&#34;&#34;Collection of tagged comments with additional contextual information.&#34;&#34;&#34;

    file_path: Path
    tagged_comments: List[_TaggedComment]


@log_fun
def _compile_issue_regex(regex_raw: str, tags: List[str]) -&gt; Pattern[str]:
    &#34;&#34;&#34;Compile the regex for the specified raw regular expression string and tags.

    Args:
        regex_raw: string regular expression that contains `{tag}`
        tags: string of tag names to match

    Returns:
        Pattern[str]: compiled regular expression to match all of the specified tags

    &#34;&#34;&#34;
    return re.compile(regex_raw.format(tag=&#39;|&#39;.join(tags)))


_regex_raw = r&#39;((\s|\()(?P&lt;tag&gt;{tag})(:[^\r\n]))(?P&lt;text&gt;.+)&#39;
_tags = [&#39;DEBUG&#39;, &#39;FIXME&#39;, &#39;FYI&#39;, &#39;HACK&#39;, &#39;NOTE&#39;, &#39;PLANNED&#39;, &#39;REVIEW&#39;, &#39;TBD&#39;, &#39;TODO&#39;]  # noqa: T100,T101,T103

_COMPILED_RE = _compile_issue_regex(_regex_raw, _tags)
&#34;&#34;&#34;Default compiled regular expression.&#34;&#34;&#34;


@log_fun
def _search_lines(lines: Sequence[str],
                  regex_compiled: Pattern[str] = _COMPILED_RE) -&gt; List[_TaggedComment]:
    &#34;&#34;&#34;Search lines of text for matches to the compiled regular expression.

    Args:
        lines: lines of text as list
        regex_compiled: compiled regular expression. Expected to have matching groups `(tag, text)`

    Returns:
        List[_TaggedComment]: list of all tagged comments found in lines

    &#34;&#34;&#34;
    comments = []
    for lineno, line in enumerate(lines):
        match = regex_compiled.search(line)
        if lineno &lt;= 3 and &#39;:skip_tags:&#39; in line:
            break
        elif match:
            mg = match.groupdict()
            comments.append(_TaggedComment(lineno + 1, tag=mg[&#39;tag&#39;], text=mg[&#39;text&#39;]))
    return comments


@log_fun
def _search_files(file_paths: Sequence[Path],
                  regex_compiled: Pattern[str] = _COMPILED_RE) -&gt; List[_Tags]:
    &#34;&#34;&#34;Collect matches from multiple files.

    Args:
        file_paths: list of files to parse
        regex_compiled: compiled regular expression. Expected to have matching groups `(tag, text)`

    Returns:
        List[_Tags]: list of all tagged comments found in files

    &#34;&#34;&#34;
    matches = []
    for file_path in file_paths:
        lines = []
        try:
            lines = read_lines(file_path)
        except UnicodeDecodeError as err:
            logger.warning(f&#39;Could not parse: {file_path}&#39;, err=err)

        comments = _search_lines(lines, regex_compiled)
        if comments:
            matches.append(_Tags(file_path, comments))

    return matches


@log_fun
def _format_report(base_dir: Path, tagged_collection: List[_Tags]) -&gt; str:  # noqa: CCR001
    &#34;&#34;&#34;Pretty-format the tagged items by file and line number.

    Args:
        base_dir: base directory relative to the searched files
        tagged_collection: list of all tagged comments found in files

    Returns:
        str: pretty-formatted text

    &#34;&#34;&#34;
    history = []
    output = &#39;&#39;
    counter = defaultdict(lambda: 0)
    for comments in sorted(tagged_collection, key=lambda tc: tc.file_path, reverse=False):
        output += f&#39;{comments.file_path.relative_to(base_dir)}\n&#39;
        for comment in comments.tagged_comments:
            combined = comment.tag + comment.text
            if combined not in history:
                output += f&#39;    line {comment.lineno:&gt;3} {comment.tag:&gt;7}: {comment.text}\n&#39;
                counter[comment.tag] += 1
            history.append(combined)
        output += &#39;\n&#39;

    formatted_summary = &#39;,  &#39;.join([f&#39;{tag} ({count})&#39; for tag, count in counter.items()])
    if formatted_summary:
        output += f&#39;Found tagged comments for {formatted_summary}\n&#39;
    return output


@log_fun
def _find_files() -&gt; List[Path]:
    &#34;&#34;&#34;Find files within the project directory that should be parsed for tags. Ignores .venv, output, etc.

    Returns:
        List[Path]: list of file paths to parse

    &#34;&#34;&#34;
    file_paths = [pth for pth in DIG.source_path.glob(&#39;*.*&#39;) if pth.name not in [_TAG_SUMMARY_FILENAME]]
    dir_paths = [*DIG.source_path.glob(&#39;*&#39;)]
    for dir_files in dir_paths:
        if dir_files.name not in [&#39;.venv&#39;, DIG.doc_dir.name]:
            file_paths.extend(dir_files.rglob(&#39;*.*&#39;))
    logger.debug(f&#39;Found {len(file_paths)} files in {len(dir_paths)} dir&#39;, file_paths=file_paths, dir_paths=dir_paths)
    return file_paths


@log_fun
def _create_tag_file(path_tag_summary: Path) -&gt; None:
    &#34;&#34;&#34;Create the tag summary file.

    Args:
        path_tag_summary: Path to the output file

    &#34;&#34;&#34;
    header = f&#39;# Task Summary\n\nAuto-Generated by {__pkg_name__}\n\n```log\n&#39;
    footer = &#39;```\n&#39;
    matches = _search_files(_find_files())
    report = _format_report(DIG.source_path, matches)
    if report.strip():
        path_tag_summary.write_text(header + report + footer)
    elif path_tag_summary.is_file():
        path_tag_summary.unlink()


@log_fun
def task_create_tag_file() -&gt; DoItTask:
    &#34;&#34;&#34;Create a summary file with all of the found tagged comments.

    Returns:
        DoItTask: DoIt task

    &#34;&#34;&#34;
    path_tag_summary = DIG.source_path / _TAG_SUMMARY_FILENAME
    return debug_task([(_create_tag_file, (path_tag_summary, ))])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dash_dev.tag_collector.task_create_tag_file"><code class="name flex">
<span>def <span class="ident">task_create_tag_file</span></span>(<span>) ‑> <function NewType.<locals>.new_type at 0x7fcc80e429d0></span>
</code></dt>
<dd>
<div class="desc"><p>Create a summary file with all of the found tagged comments.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DoItTask</code></dt>
<dd>DoIt task</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@log_fun
def task_create_tag_file() -&gt; DoItTask:
    &#34;&#34;&#34;Create a summary file with all of the found tagged comments.

    Returns:
        DoItTask: DoIt task

    &#34;&#34;&#34;
    path_tag_summary = DIG.source_path / _TAG_SUMMARY_FILENAME
    return debug_task([(_create_tag_file, (path_tag_summary, ))])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = 'search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dash_dev" href="index.html">dash_dev</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dash_dev.tag_collector.task_create_tag_file" href="#dash_dev.tag_collector.task_create_tag_file">task_create_tag_file</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>