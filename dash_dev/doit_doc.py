"""DoIt Documentation Utilities."""

import json
import re
import shutil
import tempfile
from pathlib import Path

import toml
from transitions import Machine

from .doit_base import DIG, debug_action, open_in_browser

# ----------------------------------------------------------------------------------------------------------------------
# Manage Changelog


def task_update_cl():
    """Update a Changelog file with the raw Git history.

    Returns:
        dict: DoIt task

    """
    return debug_action(['gitchangelog > CHANGELOG-raw.md'])


def task_create_tag():
    """Create a git tag based on the version in pyproject.toml.

    Returns:
        dict: DoIt task

    """
    version = toml.load(DIG.toml_pth)['tool']['poetry']['version']
    message = 'New Revision from PyProject.toml'
    return debug_action([
        f'git tag -a {version} -m "{message}"',
        'git tag -n10 --list',
        'git push origin --tags',
    ])


def task_remove_tag():
    """Delete tag for current version in pyproject.toml.

    Returns:
        dict: DoIt task

    """
    version = toml.load(DIG.toml_pth)['tool']['poetry']['version']
    return debug_action([
        f'git tag -d "{version}"',
        'git tag -n10 --list',
        f'git push origin :refs/tags/{version}',
    ])


# ----------------------------------------------------------------------------------------------------------------------
# Manage Documentation

PDocConfig = """<%!
    show_inherited_members = True
    hljs_stylename = 'atom-one-light'
%>"""

PDocHead = """<style>
    a {
        text-decoration: underline;
    }
    h1,h2,h3,h4 {
        font-weight: 400;
    }
    main {
        margin-bottom: 80vh;
    }
    #content {
        max-width: 1100px;
    }
    .source summary {
        background-color: #fafafa; /* match HLJS backgd */
        padding: 1px 5px;
    }
    .source summary:focus {
        outline: none !important;
    }
    .source pre {
        background-color: #fafafa; /* match HLJS backgd */
    }
    .source pre code {
        padding-bottom: 1em;
    }
</style>"""


def write_pdoc_config_files():
    """Write the head and config mako files for pdoc."""
    (DIG.doc_dir / 'head.mako').write_text(PDocHead)
    (DIG.doc_dir / 'config.mako').write_text(PDocConfig)


def clear_docs():
    """Clear the documentation directory before running pdoc."""
    if DIG.staging_dir.is_dir():
        shutil.rmtree(DIG.staging_dir)


def stage_documentation():
    """Copy the documentation files from the staging to the output."""
    if DIG.gh_pages_dir.is_dir():
        tmp_dir = Path(tempfile.mkdtemp())
        (DIG.gh_pages_dir / '.git').rename(tmp_dir / '.git')
        try:
            shutil.rmtree(DIG.gh_pages_dir)
            shutil.copytree(DIG.staging_dir, DIG.gh_pages_dir)
            (DIG.gh_pages_dir / 'README.md').write_text(f"""# {DIG.pkg_name.upper()} Documentation Site
    See `master` branch for latest code. This branch is auto-generated by pdoc""")
        finally:
            (tmp_dir / '.git').rename(DIG.gh_pages_dir / '.git')
            shutil.rmtree(tmp_dir)


def stage_examples():
    """Format the code examples as docstrings to be loaded into the documentation."""
    DIG.tmp_examples_dir.mkdir(exist_ok=False)
    (DIG.tmp_examples_dir / '__init__.py').write_text('"""Code Examples (documentation-only, not in package)."""')
    for file_path in DIG.src_examples_dir.glob('*.py'):
        content = file_path.read_text().replace('"', r'\"')  # read and escape quotes
        dest_fn = DIG.tmp_examples_dir / file_path.name
        docstring = f'From file: `{file_path.relative_to(DIG.cwd.parent)}`'
        dest_fn.write_text(f'"""{docstring}\n```\n{content}\n```\n"""')


def clear_examples():
    """Clear the examples from within the package directory."""
    if DIG.tmp_examples_dir.is_dir():
        shutil.rmtree(DIG.tmp_examples_dir)


class ReadMeMachine:  # noqa: H601
    """State machine to replace commented sections of readme with new text."""

    states = ['readme', 'new']

    transitions = [
        {'trigger': 'start_new', 'source': 'readme', 'dest': 'new'},
        {'trigger': 'end', 'source': 'new', 'dest': 'readme'},
    ]

    readme_lines = None

    def __init__(self):
        """Initialize state machine."""
        self.machine = Machine(model=self, states=self.states, initial='readme', transitions=self.transitions)

    def parse(self, lines, comment_pattern, new_text):  # noqa: CCR001
        """Parse lines and insert new_text.

        Args:
            lines: list of text files
            comment_pattern: comment pattern to match (ex: ``)
            new_text: dictionary with comment string as key

        Returns:
            list: list of strings for README

        """
        self.readme_lines = []
        for line in lines:
            if comment_pattern.match(line):
                self.readme_lines.append(line)
                if line.strip().startswith('<!-- /'):
                    self.end()
                else:
                    key = comment_pattern.match(line).group(1)
                    self.readme_lines.extend(['', *new_text[key], ''])
                    self.start_new()
            elif self.state == 'readme':
                self.readme_lines.append(line)

        return self.readme_lines


def write_to_readme(comment_pattern, new_text):
    """Wrap ReadMeMachine. Handle reading then writing changes to the README.

    Args:
        comment_pattern: comment pattern to match (ex: ``)
        new_text: dictionary with comment string as key

    """
    readme_path = DIG.cwd / 'README.md'
    lines = readme_path.read_text().split('\n')
    readme_lines = ReadMeMachine().parse(lines, comment_pattern, new_text)
    readme_path.write_text('\n'.join(readme_lines))


def write_code_to_readme():
    """Replace commented sections in README with linked file contents."""
    comment_pattern = re.compile(r'\s*<!-- /?(CODE:.*) -->')
    fn = 'tests/examples/readme.py'
    script_path = DIG.cwd / fn
    if script_path.is_file():
        source_code = ['```py', *script_path.read_text().split('\n'), '```']
        new_text = {f'CODE:{fn}': [f'    {line}'.rstrip() for line in source_code]}
        write_to_readme(comment_pattern, new_text)


def write_coverage_to_readme():
    """Read the coverage.json file and write a Markdown table to the README file."""
    # Read coverage information from json file
    coverage = json.loads((DIG.cwd / 'coverage.json').read_text())
    # Collect raw data
    legend = ['File', 'Statements', 'Missing', 'Excluded', 'Coverage']
    int_keys = ['num_statements', 'missing_lines', 'excluded_lines']
    rows = [legend, ['--:'] * len(legend)]
    for file_path, file_obj in coverage['files'].items():
        rows.append([file_path.replace('dash_charts/', '')]
                    + [file_obj['summary'][key] for key in int_keys]
                    + [round(file_obj['summary']['percent_covered'], 1)])
    # Format table for Github Markdown
    table_lines = [f"| {' | '.join([str(value) for value in row])} |" for row in rows]
    table_lines.extend(['', f"Generated on: {coverage['meta']['timestamp']}"])
    # Replace coverage section in README
    comment_pattern = re.compile(r'<!-- /?(COVERAGE) -->')
    write_to_readme(comment_pattern, {'COVERAGE': table_lines})


def task_document():
    """Build the HTML documentation and push to gh-pages branch.

    Returns:
        dict: DoIt task

    """
    # Format the pdoc CLI args
    args = f'{DIG.pkg_name} --html --force --template-dir "{DIG.doc_dir}" --output-dir "{DIG.doc_dir}"'
    return debug_action([
        (clear_docs, ()),
        (clear_examples, ()),
        (write_pdoc_config_files, ()),
        (stage_examples, ()),
        (write_code_to_readme, ()),
        'coverage json',  # creates 'coverage.json' file
        (write_coverage_to_readme, ()),
        f'poetry run pdoc3 {args}',
        (clear_examples, ()),
        (stage_documentation, ()),
    ])


def task_commit_docs():
    """Commit the documentation to gh-pages.

    Returns:
        dict: DoIt task

    """
    return debug_action([
        f'cd {DIG.gh_pages_dir}; git add .; git commit -m "Chg: update pdoc files"; git push',
    ])


def task_open_docs():
    """Open the documentation files in the default browser.

    Returns:
        dict: DoIt task

    """
    return debug_action([
        (open_in_browser, (DIG.staging_dir / 'index.html',)),
    ])
